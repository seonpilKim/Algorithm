# ìµœì†Œ ê³µí†µ ì¡°ìƒ(Lowest Common Ancestor) ì•Œê³ ë¦¬ì¦˜

## ğŸ’¡ ë„ì… ë°°ê²½
- ì˜ˆë¥¼ ë“¤ì–´ íŠ¸ë¦¬ì—ì„œ ì„ì˜ì˜ ë‘ ë…¸ë“œë¥¼ ì„ íƒí•˜ê³ , ë‘ ë…¸ë“œì˜ ìµœì†Œ ê³µí†µ ì¡°ìƒì„ ì°¾ìœ¼ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œ?
	- ê°„ë‹¨íˆ ë‘ ë…¸ë“œë¥¼ í•œ ë²ˆì”© ê°ìì˜ ë¶€ëª¨ ë…¸ë“œë¡œ ì˜¬ë¼ê°€ë©´ì„œ ì°¾ì„ ìˆ˜ ìˆë‹¤.
		- ì‹œê°„ ë³µì¡ë„: `O(N)`
	- ë§Œì•½ íŠ¸ë¦¬ì— ë…¸ë“œê°€ ë¬´ìˆ˜íˆ ë§ë‹¤ê³  í•  ë•Œ, ìœ„ì˜ ì‘ì—…ì„ ì—¬ëŸ¬ ë²ˆ í•´ì•¼ í•œë‹¤ë©´ ì–´ë–¨ê¹Œ?
		- ì´ë¯¸ ì§€ë‹ˆê°„ ê²½ë¡œë“¤ë„ ê³„ì† í™•ì¸í•´ì•¼ í•˜ë¯€ë¡œ, ë§¤ìš° ë¹„íš¨ìœ¨ì ì´ë‹¤.
		- ì‹œê°„ ë³µì¡ë„: `O(N * M)`
- ë‘ ë…¸ë“œì˜ ìµœì†Œ ê³µí†µ ì¡°ìƒì„ ë” ë¹ ë¥´ê²Œ ì°¾ì„ ìˆ˜ ìˆëŠ” ë°©ë²•ì€ ì—†ì„ê¹Œ?
## ğŸ“– ê°œë…
- í˜„ì¬ ë…¸ë“œì˜ `2^ië²ˆì§¸ ë¶€ëª¨ ë…¸ë“œ`ë¥¼ ì €ì¥í•˜ëŠ” `í¬ì†Œ ë°°ì—´(Sparse table)`ì„ ë§Œë“¤ê³ , ì´ë¥¼ ì´ìš©í•˜ì—¬ ë‘ ë…¸ë“œì˜ ìµœì†Œ ê³µí†µ ì¡°ìƒì„ ì°¾ëŠ”ë‹¤.
	- `par[n][i] = ë…¸ë“œ ë²ˆí˜¸ê°€ nì¸ ë…¸ë“œì˜ 2^ië²ˆì¨° ë¶€ëª¨ì˜ ë…¸ë“œ ë²ˆí˜¸`
- í˜„ì¬ ë…¸ë“œë¶€í„° 1 -> 2 -> 4 -> 8... ë²ˆì§¸ ë¶€ëª¨ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ íƒìƒ‰í•˜ê¸° ë•Œë¬¸ì—, ê¸°ì¡´ì˜ ë°©ë²•ë³´ë‹¤ í›¨ì”¬ ë¹ ë¥´ê²Œ ìµœì†Œ ê³µí†µ ì¡°ìƒì„ ì°¾ì„ ìˆ˜ ìˆë‹¤.
## ğŸ•’ ì‹œê°„ ë³µì¡ë„
- `O(logâ‚‚N)`
## âš™ ì›ë¦¬
![image](https://user-images.githubusercontent.com/68049320/151838381-89919176-f8dc-48cc-858c-13a3b1071a32.png)
- ë¨¼ì € ê° `ë…¸ë“œì˜ ê¹Šì´(depth)`ì™€ ê° ë…¸ë“œë§ˆë‹¤ `2^i ë²ˆì¨° ë¶€ëª¨ ë…¸ë“œì˜ ì •ë³´`ë¥¼ ì €ì¥í•´ì•¼ í•œë‹¤.
	- `DFS`ë¥¼ ì´ìš©í•˜ì—¬ ê° `ë…¸ë“œì˜ ê¹Šì´`ë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤.
		- ì´ ê³¼ì •ì—ì„œ `2^0ë²ˆì§¸ ë¶€ëª¨`ë„ ì €ì¥í•œë‹¤.
		```c++
		void DFS(int cur) {
		    for (int next : adj[cur]) {
		        if (depth[next] == -1) { // ë°©ë¬¸ xì¸ ê²½ìš°
		            par[next][0] = cur;
		            depth[next] = depth[cur] + 1;
		            DFS(next);
		        }
		    }
		}
		```
	- 2ì¤‘ forë¬¸ì„ ì´ìš©í•˜ì—¬ `ê° ë…¸ë“œì˜ 2^ië²ˆì§¸ ë¶€ëª¨`ë¥¼ ì €ì¥í•œë‹¤.
		```c++
		for (int h = 0; h < MAX - 1; h++) {
			 // root ë¶€ëª¨ëŠ” ì„¤ì •í•  í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ, 2ë²ˆ ë…¸ë“œë¶€í„° ì„¤ì •
   		     for (int i = 2; i <= N; i++) { 
   		         int p = par[i][h];
   		         if (p != -1) // ië²ˆ ë…¸ë“œì˜ 2^hë²ˆì§¸ ë¶€ëª¨ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°
   		             par[i][h + 1] = par[p][h];
   		     }
   		 }
		```
- ë‹¤ìŒìœ¼ë¡œ ë‘ ë…¸ë“œì˜ ê¹Šì´ë¥¼ ë§ì¶°ì¤€ ë‹¤ìŒ, ë‘ ë…¸ë“œë¥¼ ê°™ì´ ë¶€ëª¨ë¡œ ì˜¬ë¦¬ë©´ì„œ ìµœì†Œ ê³µí†µ ì¡°ìƒì„ ì°¾ëŠ”ë‹¤.
	```c++
	int LCA(int u, int v) {
	    if (depth[u] < depth[v])
	        swap(u, v);

	    int diff = depth[u] - depth[v];
	    int h = 0;
		// ë¨¼ì € ë‘ ë…¸ë“œì˜ ê¹Šì´ë¥¼ ë§ì¶˜ë‹¤.
	    while (diff) {
	        if (diff % 2)
	            u = par[u][h];
	        h++;
	        diff /= 2;
	    }

	    if (u != v) {
			// ì˜ˆë¥¼ ë“¤ì–´ 11ë²ˆì§¸ ë¶€ëª¨ë¼ë©´, 8 -> 2 -> 1 ìˆœì„œëŒ€ë¡œ íƒìƒ‰í•´ì•¼ í•˜ë¯€ë¡œ, ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ íƒìƒ‰
	        for (int h = MAX - 1; h >= 0; h--) {
				// ë¶€ëª¨ê°€ ë‹¤ë¥¸ ê²½ìš°, í•´ë‹¹ ë¶€ëª¨ ë…¸ë“œë¡œ ê°±ì‹ 
	            if (par[u][h] != par[v][h]) {
	                u = par[u][h];
	                v = par[v][h];
	            }
	        }

			// ìµœì†Œ ê³µí†µ ì¡°ìƒ
	        return par[u][0];
	    }

		// ë‘ ë…¸ë“œ ì¤‘ í•˜ë‚˜ê°€ ë¶€ëª¨ì¸ ê²½ìš°
	    return u;
	}
	```
## ğŸ¤” ì‘ìš©
- ì£¼ë¡œ íŠ¸ë¦¬ì—ì„œ `ë‘ ë…¸ë“œì˜ ì‚¬ì´ì˜ ê±°ë¦¬`, `ë‘ ë…¸ë“œì˜ ê²½ë¡œ ì¤‘ ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ í° ê°„ì„ ` êµ¬í•˜ê¸° ë“±ì—ì„œ ì‚¬ìš©ëœë‹¤.
## ğŸ’»êµ¬í˜„ ì½”ë“œ
```c++
int N, M;
vector<vector<int>> par, adj;
vector<int> depth;
const int MAX = 18; // ë³´í†µ logâ‚‚N + 2 ì •ë„ë¡œ ì„¤ì •

void DFS(int cur) {
    for (int next : adj[cur]) {
        if (depth[next] == -1) {
            par[next][0] = cur;
            depth[next] = depth[cur] + 1;
            DFS(next);
        }
    }
}

void init() {
    cin >> N;
    adj.resize(N + 1);
    depth.assign(N + 1, -1);
    par.assign(N + 1, vector<int>(MAX, -1));

    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    depth[1] = 0;
    DFS(1);
    for (int h = 0; h < MAX - 1; h++) {
        for (int i = 2; i <= N; i++) {
            int p = par[i][h];
            if (p != -1)
                par[i][h + 1] = par[p][h];
        }
    }

    cin >> M;
}

int LCA(int u, int v) {
    if (depth[u] < depth[v])
        swap(u, v);

    int diff = depth[u] - depth[v];
    int h = 0;
    while (diff) {
        if (diff % 2)
            u = par[u][h];
        h++;
        diff /= 2;
    }

    if (u != v) {
        for (int h = MAX - 1; h >= 0; h--) {
            if (par[u][h] != par[v][h]) {
                u = par[u][h];
                v = par[v][h];
            }
        }

        return par[u][0];
    }

    return u;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    init();
    for (int i = 0; i < M; i++) {
        int u, v;
        cin >> u >> v;
        cout << LCA(u, v) << '\n';
    }

    return 0;
}
```