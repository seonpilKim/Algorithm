# [[1562] 계단 수](https://www.acmicpc.net/problem/1562)

![](imgs/1.PNG)
![](imgs/2.PNG)
___
## 🤔접근
1. <b>계단 수란?</b>
	- 인접한 모든 자리수의 차이가 1인 수.
	- 0으로 시작하는 수는 없음.
	- `동적계획법`으로 길이가 N인 계단 수의 총 개수를 구할 수 있다.
		- `dp[길이][끝 자리 수] = dp[길이 - 1][끝 자리 수 - 1] + dp[길이 - 1][끝 자리 수 + 1]`
		- 주의: 끝 자리가 `0`인 경우에는 `dp[길이 - 1][끝 자리수 + 1]`, `9`인 경우에는 `dp[길이 - 1][끝 자리 수 - 1]`만 더한다.
2. <b>길이가 N이면서 0 ~ 9 모두 등장하는 계단 수를 구해야 한다.</b>
	- 0 ~ 9 사용 여부를 `bitmask`를 이용하여 표현하자.
___
## 💡풀이
- <b>Bottom-up 동적계획법 알고리즘</b>을(를) 사용하였다.
	- 계단 수를 구할 때, 각 경우의 수에서 `0 ~ 9 사용 여부`도 추가로 알고 있어야 한다.
	- 즉, `dp[길이][끝 자리 수]`를 이루는 계단 수들 중에서 사용된 숫자들을 추가로 dp에 담고 있어야 하므로, `dp[길이][끝 자리 수][bitmask]`으로 표현할 수 있다.
	- bitmask는 총 10개의 숫자의 사용 여부를 표현해야 하므로 `2¹⁰` 크기만큼 메모리를 할당하면 된다.
	- 기저 조건으로는 길이가 1일 때, 1부터 9까지 각각 끝 자리 수와 사용된 숫자가 동일하며, 경우의 수는 모두 1가지 이므로 다음과 같이 표현할 수 있다.
		```c++
		for(int i = 1; i < 10; i++){
			dp[1][i][1 << i] = 1;
		}
		```
	- 계단 수를 동적계획법으로 구현하는 코드에서 한 가지만 추가해주면 된다.
		- 반복문 하나를 가장 안쪽에 추가하고, 0 ~ 9 숫자를 조합하는 모든 경우의 수를 탐색한다.
		- 즉, `bit = 0 부터 bit = 1024 까지` 탐색한다.
	- 이전 계단 수를 구하는 시간 복잡도가 `O(10 * N)`이었다면, 0 ~ 9까지 각각 하나씩 사용한 경우의 수를 구하는 시간 복잡도는 `O(10 * N * 1024)`이다.
__
## ✍ 피드백
___
## 💻 핵심 코드
```c++
vector<vector<vector<int>>> dp(N + 1, vector<vector<int>>(10, vector<int>(MAXBIT)));
for (int i = 1; i < 10; i++) // base condition
	dp[1][i][1 << i] = 1;
	
for (int n = 2; n <= N; n++) // bottom-up
	for (int endNum = 0; endNum < 10; endNum++) 
		for (int bit = 0; bit < MAXBIT; bit++) 
			dp[n][endNum][bit | (1 << endNum)] = (dp[n][endNum][bit | (1 << endNum)] + (endNum == 0 ? 0 : dp[n - 1][endNum - 1][bit]) + (endNum == 9 ? 0 : dp[n - 1][endNum + 1][bit])) % MOD;
			
int ans = 0;
for (int i = 0; i < 10; i++)
	ans = (ans + dp[N][i][MAXBIT - 1]) % MOD;

cout << ans;
```