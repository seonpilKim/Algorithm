# [[2293] 동전 1](https://www.acmicpc.net/problem/2293)

![](imgs/1.PNG)

___
## 💡풀이
- <b>동적계획법을 이용하였다.</b>
	- 분석
		> 예를들어 1, 2, 3원짜리 동전이 있다고 가정해보자.
		> - 그럼 1원 동전으로 만들 수 있는 경우는 다음과 같다.
		>	1. 1원 동전 1개로 1원 만들기
		>	2. 1원 동전 2개로 2원 만들기
		>	3. 1원 동전 3개로 3원 만들기
		> - 2원 동전으로 만들 수 있는 경우
		>	1. 2원 동전 1개로 2원
		>	2. 2원 동전 1개, 1원 동전 1개로 3원
		> 	- 2원 동전으로는 절대로 1원을 만들 수 없다.
		> - 3원 동전으로 만들 수 있는 경우
		>	1. 3원 동전 1개로 3원
		>	- 3원 동전으로는 절대로 1, 2원을 만들 수 없다.
		- 위의 예시를 통해 `dp[i] = j`를 `i원을 만들 수 있는 경우는 j가지`라고 정의하고 점화식을 세워보면 다음과 같다.
			- <b>Bottom-up 점화식</b>
				```c++
				for (int i = 1; i <= n; i++) 
					for (int j = coin[i]; j <= k; j++) 
						dp[j] += dp[j - coin[i]];
				```
			- 현재 i원인 동전을 이용하여 j원을 만들고 싶다면, dp[j] += dp[j - i]가 된다.
			- 그 동전이 가진 가치만큼을 뺀 나머지 액수를 만드는 경우의 수가 더해진다는 의미이다.
		- 시간 복잡도 : `O(n * k)` : 최대 10^6번 실행 (n=100, k=10000)
___
## ✍ 피드백
- 처음에는 DFS를 이용하여 제출해봤지만 TLE..!
	```c++
	void DFS(int idx, int sum) {
		if (sum >= k || idx == v.size()) {
			if (sum == k)
				cnt++;
			return;
		}

		DFS(idx, sum + v[idx]);
		DFS(idx + 1, sum);
	}
	```
	- 결과는 동일하게 출력되지만, 시간초과가 발생하였다.
	- 이유는 완전탐색을 하기 때문이다.
___
## 💻 핵심 코드
```c++
// base condition
	dp[0] = 1;

	// bottom-up
	for (int i = 1; i <= n; i++) 
		for (int j = coin[i]; j <= k; j++) 
			dp[j] += dp[j - coin[i]];
	
	cout << dp[k];
```